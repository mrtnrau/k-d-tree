theory hw_orginal_1
imports
  Complex_Main
begin

type_synonym point = "real list"
type_synonym axis = nat
type_synonym dimension = nat
type_synonym split = real

definition dim :: "point \<Rightarrow> nat"  where
  "dim p = length p"

definition incr :: "axis \<Rightarrow> dimension \<Rightarrow> axis" where
  "incr a d = (a + 1) mod d"

declare dim_def[simp]
declare incr_def[simp]

datatype kdt =
  Leaf point
| Node kdt split kdt

fun set_kdt :: "kdt \<Rightarrow> point set" where
  "set_kdt (Leaf p) = {p}"
| "set_kdt (Node l _ r) = set_kdt l \<union> set_kdt r"

fun invar' :: "axis \<Rightarrow> dimension \<Rightarrow> kdt \<Rightarrow> bool" where
  "invar' _ k (Leaf p) \<longleftrightarrow> k > 0 \<and> dim p = k"
| "invar' a k (Node l s r) \<longleftrightarrow> (\<forall>p \<in> set_kdt l. p!a \<le> s) \<and> (\<forall>p \<in> set_kdt r. p!a > s) \<and>
    invar' (incr a k) k l \<and> invar' (incr a k) k r"

lemma invar'_l_r:
  assumes "invar' a k (Node l s r)"
  shows "invar' (incr a k) k l \<and> invar' (incr a k) k r"
  using assms
  by simp

lemma set_kdt_dim:
  assumes "invar' a k kdt"
  shows "\<forall>p \<in> set_kdt kdt. dim p = k"
  using assms
  by (induction kdt arbitrary: a) auto

lemma set_kdt_l_lq_a: 
  assumes "invar' a k kdt" "kdt = Node l s r"
  shows "\<forall>p \<in> set_kdt l. p!a \<le> s"
  using assms by (induction kdt arbitrary: a) auto

lemma set_kdt_r_gt_a: 
  assumes "invar' a k kdt" "kdt = Node l s r"
  shows "\<forall>p \<in> set_kdt r. s < p!a"
  using assms by (induction kdt arbitrary: a) auto

definition squared_distance' :: "real \<Rightarrow> real \<Rightarrow> real" where
  "squared_distance' x y = (x - y) ^ 2"

lemma squared_distance'_ge_0:
  "squared_distance' x y \<ge> 0"
  using squared_distance'_def by simp

lemma squared_distance'_eq_0[simp]:
  "squared_distance' x y = 0 \<longleftrightarrow> x = y"
  using squared_distance'_def by simp

fun squared_distance :: "point \<Rightarrow> point \<Rightarrow> real" where
  "squared_distance [] [] = 0"
| "squared_distance (x # xs) (y # ys) = squared_distance' x y + squared_distance xs ys"
| "squared_distance _ _ = undefined"

lemma squared_distance_ge_0:
  assumes "dim p\<^sub>0 = dim p\<^sub>1"
  shows "squared_distance p\<^sub>0 p\<^sub>1 \<ge> 0"
  using assms
  by (induction p\<^sub>0 p\<^sub>1 rule: squared_distance.induct) (auto simp add: squared_distance'_ge_0)

lemma squared_distance_eq_0[simp]:
  assumes "p\<^sub>0 = p\<^sub>1"
  shows "squared_distance p\<^sub>0 p\<^sub>1 = 0"
  using assms 
  by(induction p\<^sub>0 p\<^sub>1 rule: squared_distance.induct) auto

definition min_by_squared_distance :: "point \<Rightarrow> point \<Rightarrow> point \<Rightarrow> point" where
  "min_by_squared_distance p\<^sub>0 p\<^sub>1 q = (
    if squared_distance p\<^sub>0 q \<le> squared_distance p\<^sub>1 q then p\<^sub>0 else p\<^sub>1
  )"

fun nearest_neighbor' :: "axis \<Rightarrow> dimension \<Rightarrow> point \<Rightarrow> kdt \<Rightarrow> point" where
  "nearest_neighbor' _ _ _ (Leaf p) = p"
| "nearest_neighbor' a k p (Node l s r) = (
    if p!a \<le> s then
      let candidate = nearest_neighbor' (incr a k) k p l in
      if squared_distance p candidate \<le> squared_distance' s (candidate!a) then
        candidate
      else
        let candidate' = nearest_neighbor' (incr a k) k p r in
        min_by_squared_distance candidate candidate' p
    else
      let candidate = nearest_neighbor' (incr a k) k p r in
      if squared_distance p candidate < squared_distance' s (candidate!a) then
        candidate
      else
        let candidate' = nearest_neighbor' (incr a k) k p l in
        min_by_squared_distance candidate candidate' p
  )"

lemma nearest_neighbor'_in_kdt:
  assumes "invar' a k kdt" "dim p = k"
  shows "nearest_neighbor' a k p kdt \<in> set_kdt kdt"
  using assms
  by (induction kdt arbitrary: a) (auto simp add: Let_def min_by_squared_distance_def)

lemma nearest_neighbor'_optimum:
  assumes "invar' a k kdt" "dim p = k"
  shows "\<forall>q \<in> set_kdt kdt. squared_distance (nearest_neighbor' a k p kdt) p \<le> squared_distance q p"
  using assms
proof (induction kdt arbitrary: a)
  case (Leaf p)
  thus ?case by simp
next
  case (Node l s r)
  consider (A) "p!a \<le> s" | (B) "p!a > s"
    by fastforce
  thus ?case
  proof cases
    case A
    let ?candidate = "nearest_neighbor' (incr a k) k p l"
    show ?thesis
    proof (cases "squared_distance p ?candidate \<le> squared_distance' s (?candidate!a)")
      case True
      thm Node
      have "\<forall>q\<in>set_kdt l. squared_distance (nearest_neighbor' (incr a k) k p l) p \<le> squared_distance q p"
        using Node sledgehammer
      then show ?thesis sorry
    next
      case False
      then show ?thesis sorry
    qed
  next
    case B
    show ?thesis sorry
  qed
qed

theorem nearest_neighbor':
  assumes "invar' a k kdt" "dim p = k" "set_kdt kdt \<noteq> {}"
  shows "(\<forall>q \<in> set_kdt kdt. squared_distance (nearest_neighbor' a k p kdt) p \<le> squared_distance q p) \<and> nearest_neighbor' a k p kdt \<in> set_kdt kdt"
  using assms nearest_neighbor'_in_kdt nearest_neighbor'_optimum by simp

end